{"ast":null,"code":"import { createContext, createElement, PureComponent, Fragment, Component, createRef } from 'react';\nimport { ViewportProvider, ObserveViewport, requestAnimationFrame } from 'react-viewport-utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar StickyGroupContext = createContext({\n  stickyOffset: {\n    top: 0,\n    height: 0\n  },\n  updateStickyOffset: function (offset, height) {}\n});\n\nvar connect = function () {\n  return function (WrappedComponent) {\n    var ConnectedComponent = function (props) {\n      return createElement(StickyGroupContext.Consumer, null, function (context) {\n        return createElement(WrappedComponent, __assign({}, props, {\n          stickyOffset: context.stickyOffset,\n          updateStickyOffset: context.updateStickyOffset\n        }));\n      });\n    };\n\n    var displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    ConnectedComponent.displayName = \"connectSticky(\" + displayName + \")\";\n    return ConnectedComponent;\n  };\n};\n\nvar StickyScrollUpProvider =\n/** @class */\nfunction (_super) {\n  __extends(StickyScrollUpProvider, _super);\n\n  function StickyScrollUpProvider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.stickyOffset = {\n      top: 0,\n      height: 0\n    };\n\n    _this.updateStickyOffset = function (stickyOffset, height) {\n      _this.stickyOffset.top = Math.min(stickyOffset, height);\n      _this.stickyOffset.height = height;\n    };\n\n    return _this;\n  }\n\n  StickyScrollUpProvider.prototype.render = function () {\n    return createElement(ViewportProvider, {\n      experimentalSchedulerEnabled: true\n    }, createElement(StickyGroupContext.Provider, {\n      value: {\n        updateStickyOffset: this.updateStickyOffset,\n        stickyOffset: this.stickyOffset\n      }\n    }, this.props.children));\n  };\n\n  return StickyScrollUpProvider;\n}(PureComponent);\n\nvar baseStyles = {\n  width: 'inherit'\n};\n\nvar prefixTransform = function (transform) {\n  return {\n    transform: transform,\n    WebkitTransform: transform,\n    msTransform: transform,\n    OTransform: transform\n  };\n};\n\nvar StickyElement = function (_a) {\n  var children = _a.children,\n      forwardRef = _a.forwardRef,\n      _b = _a.style,\n      overrideStyles = _b === void 0 ? {} : _b,\n      _c = _a.positionStyle,\n      positionStyle = _c === void 0 ? {} : _c,\n      disabled = _a.disabled,\n      renderArgs = _a.renderArgs,\n      props = __rest(_a, [\"children\", \"forwardRef\", \"style\", \"positionStyle\", \"disabled\", \"renderArgs\"]);\n\n  var style = !disabled ? __assign(__assign(__assign({}, baseStyles), positionStyle), overrideStyles) : {};\n\n  if (style.transform) {\n    Object.assign(style, prefixTransform(style.transform));\n  }\n\n  return createElement(\"div\", __assign({\n    ref: forwardRef,\n    style: style\n  }, props), typeof children === 'function' ? children(renderArgs) : children);\n};\n\nvar StickyPlaceholder =\n/** @class */\nfunction (_super) {\n  __extends(StickyPlaceholder, _super);\n\n  function StickyPlaceholder() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isRecalculating: false,\n      isWaitingForRecalculation: false,\n      stickyHeight: null,\n      stickyWidth: null,\n      clientSize: null\n    };\n\n    _this.calculateSize = function () {\n      if (_this.props.stickyRef.current && !_this.state.isRecalculating && _this.state.isWaitingForRecalculation) {\n        return _this.props.stickyRef.current.getBoundingClientRect();\n      }\n\n      return null;\n    };\n\n    _this.handleDimensionsUpdate = function (_a, stickyRect) {\n      var dimensions = _a.dimensions;\n      var width = dimensions.width,\n          clientWidth = dimensions.clientWidth;\n      var nextClientSize = [width, clientWidth].join(',');\n\n      if (!_this.state.isWaitingForRecalculation && _this.state.clientSize !== nextClientSize) {\n        _this.setState({\n          clientSize: nextClientSize,\n          isRecalculating: true,\n          isWaitingForRecalculation: true\n        }, function () {\n          requestAnimationFrame(function () {\n            _this.setState({\n              isRecalculating: false\n            });\n          });\n        });\n\n        return;\n      }\n\n      if (stickyRect && _this.state.isWaitingForRecalculation) {\n        _this.setState({\n          clientSize: nextClientSize,\n          stickyHeight: stickyRect.height,\n          stickyWidth: stickyRect.width,\n          isWaitingForRecalculation: false\n        });\n\n        return;\n      }\n    };\n\n    return _this;\n  }\n\n  StickyPlaceholder.prototype.render = function () {\n    var _a = this.props,\n        children = _a.children,\n        disabled = _a.disabled,\n        style = _a.style,\n        className = _a.className,\n        forwardRef = _a.forwardRef;\n    var _b = this.state,\n        isRecalculating = _b.isRecalculating,\n        isWaitingForRecalculation = _b.isWaitingForRecalculation,\n        stickyHeight = _b.stickyHeight,\n        stickyWidth = _b.stickyWidth;\n    var isActive = !disabled && !isWaitingForRecalculation;\n\n    var baseStyle = __assign({\n      position: 'relative'\n    }, style);\n\n    var containerStyle = isActive ? __assign({\n      height: stickyHeight,\n      width: stickyWidth\n    }, baseStyle) : baseStyle;\n    return createElement(Fragment, null, createElement(\"div\", {\n      ref: forwardRef,\n      style: containerStyle,\n      className: className\n    }, children({\n      isRecalculating: isWaitingForRecalculation\n    })), !this.props.disableResizing && createElement(ObserveViewport, {\n      disableScrollUpdates: true,\n      disableDimensionsUpdates: isRecalculating,\n      onUpdate: this.handleDimensionsUpdate,\n      recalculateLayoutBeforeUpdate: this.calculateSize,\n      priority: \"highest\"\n    }));\n  };\n\n  StickyPlaceholder.defaultProps = {\n    style: {}\n  };\n  return StickyPlaceholder;\n}(Component);\n\nvar supportsWillChange = function () {\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && document.documentElement;\n\n  if (!isBrowser) {\n    return false;\n  }\n\n  return 'willChange' in document.documentElement.style;\n}();\n\nvar supportsPositionSticky = function () {\n  var isBrowser = typeof window !== 'undefined' && typeof CSS !== 'undefined';\n\n  if (!isBrowser) {\n    return false;\n  }\n\n  return CSS.supports ? CSS.supports('position: sticky') : false;\n}();\n\nvar shallowEqualPositionStyles = function (a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.position !== b.position) {\n    return false;\n  }\n\n  if (a.top !== b.top) {\n    return false;\n  }\n\n  if (a.transform !== b.transform) {\n    return false;\n  }\n\n  if (a.willChange !== b.willChange) {\n    return false;\n  }\n\n  return true;\n};\n\nvar Sticky =\n/** @class */\nfunction (_super) {\n  __extends(Sticky, _super);\n\n  function Sticky() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.stickyRef = createRef();\n    _this.placeholderRef = createRef();\n    _this.nativeStickyThrewOnce = false;\n    _this.state = {\n      isSticky: false,\n      isDockedToBottom: false,\n      isNearToViewport: false,\n      appliedOverflowScroll: 'end',\n      styles: {},\n      useNativeSticky: false\n    };\n\n    _this.hasContainer = function () {\n      return Boolean(_this.props.container);\n    };\n\n    _this.isNearToViewport = function (rect) {\n      var padding = 700;\n      return rect.top - padding < 0 && rect.bottom + padding > 0;\n    };\n\n    _this.getOverflowScrollType = function (rectSticky, dimensions) {\n      return _this.props.overflowScroll === 'flow' && _this.calcHeightDifference(rectSticky, dimensions) > 0 ? 'flow' : 'end';\n    };\n\n    _this.isSticky = function (rect, containerRect, dimensions) {\n      if (!_this.hasContainer()) {\n        return Math.round(containerRect.top) <= _this.offsetTop;\n      }\n\n      if (Math.round(containerRect.top) > _this.offsetTop) {\n        return false;\n      }\n\n      var height = _this.props.overflowScroll === 'flow' ? Math.min(rect.height, dimensions.height) : rect.height;\n\n      if (Math.round(containerRect.bottom) - _this.offsetTop < height) {\n        return false;\n      }\n\n      return true;\n    };\n\n    _this.shouldUseNativeSticky = function (appliedOverflowScroll) {\n      if (!_this.props.experimentalNative || !supportsPositionSticky || appliedOverflowScroll !== 'end' || _this.props.stickyOffset.top !== 0) {\n        return false;\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !_this.nativeStickyThrewOnce && (_this.placeholderRef && _this.placeholderRef.current.parentElement) !== (_this.props.container && _this.props.container.current)) {\n        console.warn('react-stickup: a sticky element was used with property `experimentalNative` but its `container` is not the parent the sticky component. As the native sticky implementation always uses its parent element as the container. This can lead to unexpected results. It is therefore recommended to change the DOM structure so that the container is a direct parent of the Sticky component or to remove the `experimentalNative` property.');\n        _this.nativeStickyThrewOnce = true;\n      }\n\n      return true;\n    };\n\n    _this.isDockedToBottom = function (rect, containerRect, dimensions) {\n      if (!rect || !containerRect) {\n        return false;\n      }\n\n      if (!_this.hasContainer()) {\n        return false;\n      }\n\n      if (rect.height > containerRect.height) {\n        return false;\n      }\n\n      var height = _this.props.overflowScroll === 'flow' ? Math.min(rect.height, dimensions.height) : rect.height;\n\n      if (Math.round(containerRect.bottom) - _this.offsetTop >= height) {\n        return false;\n      }\n\n      return true;\n    };\n\n    _this.recalculateLayoutBeforeUpdate = function () {\n      var containerRect = _this.container.current.getBoundingClientRect();\n\n      var stickyRect = _this.stickyRef.current.getBoundingClientRect();\n\n      return {\n        stickyRect: stickyRect,\n        containerRect: containerRect\n      };\n    };\n\n    _this.handleScrollUpdate = function (_a, _b) {\n      var scroll = _a.scroll,\n          dimensions = _a.dimensions;\n      var stickyRect = _b.stickyRect,\n          containerRect = _b.containerRect;\n\n      if (_this.props.disabled) {\n        return;\n      } // in case children is not a function renderArgs will never be used\n\n\n      var willRenderAsAFunction = typeof _this.props.children === 'function';\n\n      var appliedOverflowScroll = _this.getOverflowScrollType(stickyRect, dimensions);\n\n      var useNativeSticky = _this.shouldUseNativeSticky(appliedOverflowScroll);\n\n      var styles = useNativeSticky ? {} : _this.getStickyStyles(stickyRect, containerRect, scroll, dimensions);\n      var stateStyles = _this.state.styles;\n      var stylesDidChange = !shallowEqualPositionStyles(styles, stateStyles);\n      var isSticky = willRenderAsAFunction ? _this.isSticky(stickyRect, containerRect, dimensions) : false;\n      var isDockedToBottom = willRenderAsAFunction ? _this.isDockedToBottom(stickyRect, containerRect, dimensions) : false;\n\n      var isNearToViewport = _this.isNearToViewport(stickyRect);\n\n      var useNativeStickyDidChange = _this.state.useNativeSticky !== useNativeSticky;\n      var isStickyDidChange = _this.state.isSticky !== isSticky;\n      var isDockedToBottomDidChange = _this.state.isDockedToBottom !== isDockedToBottom;\n      var isNearToViewportDidChange = _this.state.isNearToViewport !== isNearToViewport;\n      var appliedOverflowScrollDidChange = appliedOverflowScroll !== _this.state.appliedOverflowScroll;\n\n      if (!useNativeStickyDidChange && !stylesDidChange && !isStickyDidChange && !isDockedToBottomDidChange && !isNearToViewportDidChange && !appliedOverflowScrollDidChange) {\n        return;\n      }\n\n      _this.setState({\n        useNativeSticky: useNativeSticky,\n        isSticky: isSticky,\n        isDockedToBottom: isDockedToBottom,\n        isNearToViewport: isNearToViewport,\n        appliedOverflowScroll: appliedOverflowScroll,\n        styles: stylesDidChange ? styles : stateStyles\n      });\n    };\n\n    _this.renderSticky = function (_a) {\n      var isRecalculating = _a.isRecalculating;\n      var _b = _this.props,\n          children = _b.children,\n          disabled = _b.disabled,\n          stickyProps = _b.stickyProps;\n      return createElement(StickyElement, __assign({\n        forwardRef: _this.stickyRef,\n        positionStyle: _this.state.styles,\n        disabled: disabled || isRecalculating,\n        children: children,\n        renderArgs: {\n          isSticky: _this.state.isSticky,\n          isDockedToBottom: _this.state.isDockedToBottom,\n          isNearToViewport: _this.state.isNearToViewport,\n          appliedOverflowScroll: _this.state.appliedOverflowScroll\n        }\n      }, stickyProps));\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(Sticky.prototype, \"container\", {\n    get: function () {\n      return this.props.container || this.placeholderRef;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sticky.prototype, \"offsetTop\", {\n    get: function () {\n      return this.props.stickyOffset.top + this.props.defaultOffsetTop;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Sticky.prototype.calcHeightDifference = function (rectSticky, dimensions) {\n    if (!dimensions) {\n      return 0;\n    }\n\n    return Math.max(0, Math.round(rectSticky.height) - dimensions.height);\n  };\n\n  Sticky.prototype.calcOverflowScrollFlowStickyStyles = function (rectSticky, containerRect, scroll, dimensions) {\n    var containerTop = Math.round(containerRect.top);\n    var stickyTop = Math.round(rectSticky.top);\n    var scrollY = Math.round(scroll.y);\n    var scrollYTurn = Math.round(scroll.yTurn);\n    var heightDiff = this.calcHeightDifference(rectSticky, dimensions);\n    var containerTopOffset = containerTop + scrollY - this.props.stickyOffset.height;\n    var isStickyBottomReached = Math.round(rectSticky.bottom) <= dimensions.height;\n    var isContainerTopReached = containerTop < this.offsetTop;\n    var isTurnWithinHeightOffset = scrollYTurn - heightDiff <= containerTopOffset;\n    var isTurnPointBeforeContainer = scrollYTurn < containerTopOffset;\n    var isTurnPointAfterContainer = scrollYTurn > containerTopOffset + containerRect.height;\n    var isTurnPointWithinContainer = !(isTurnPointBeforeContainer || isTurnPointAfterContainer); // scroll down AND sticky rect bottom not reached AND turn point not within the container OR\n    // scroll up AND container top not reached OR\n    //scroll up AND turns within the height diff AND turn point not within the container\n\n    if (scroll.isScrollingDown && !isStickyBottomReached && !isTurnPointWithinContainer || scroll.isScrollingUp && !isContainerTopReached || scroll.isScrollingUp && isTurnWithinHeightOffset && !isTurnPointWithinContainer) {\n      return {\n        position: 'absolute',\n        top: 0\n      };\n    } // scroll down AND sticky bottom reached\n\n\n    if (scroll.isScrollingDown && isStickyBottomReached) {\n      return {\n        position: 'fixed',\n        top: -heightDiff\n      };\n    }\n\n    var isStickyTopReached = stickyTop >= this.offsetTop; // scroll down AND turn point within container OR\n    // scroll up AND turn point not before container AND not sticky top reached\n\n    if (scroll.isScrollingDown && isTurnPointWithinContainer || scroll.isScrollingUp && !isTurnPointBeforeContainer && !isStickyTopReached) {\n      return {\n        position: 'absolute',\n        top: Math.abs(scrollY - stickyTop + (containerTop - scrollY))\n      };\n    }\n\n    return {\n      position: 'fixed',\n      top: this.offsetTop\n    };\n  };\n\n  Sticky.prototype.calcPositionStyles = function (rectSticky, containerRect, scroll, dimensions) {\n    if (this.isSticky(rectSticky, containerRect, dimensions)) {\n      if (this.getOverflowScrollType(rectSticky, dimensions) === 'flow') {\n        return this.calcOverflowScrollFlowStickyStyles(rectSticky, containerRect, scroll, dimensions);\n      }\n\n      var stickyOffset = this.props.stickyOffset.top;\n      var stickyHeight = this.props.stickyOffset.height;\n      var headIsFlexible = stickyOffset > 0 && stickyOffset < stickyHeight;\n\n      if (headIsFlexible) {\n        var relYTurn = Math.round(scroll.yTurn - scroll.y + scroll.yDTurn) - Math.round(containerRect.top);\n        return {\n          position: 'absolute',\n          top: relYTurn + this.offsetTop\n        };\n      }\n\n      return {\n        position: 'fixed',\n        top: this.offsetTop\n      };\n    }\n\n    if (this.isDockedToBottom(rectSticky, containerRect, dimensions)) {\n      return {\n        position: 'absolute',\n        top: containerRect.height - rectSticky.height\n      };\n    }\n\n    return {\n      position: 'absolute',\n      top: 0\n    };\n  };\n\n  Sticky.prototype.getStickyStyles = function (rect, containerRect, scroll, dimensions) {\n    var styles = this.calcPositionStyles(rect, containerRect, scroll, dimensions);\n\n    if (!this.props.disableHardwareAcceleration) {\n      var shouldAccelerate = this.isNearToViewport(rect);\n\n      if (supportsWillChange) {\n        styles.willChange = shouldAccelerate ? 'position, top' : null;\n      } else {\n        styles.transform = shouldAccelerate ? \"translateZ(0)\" : null;\n      }\n    }\n\n    return styles;\n  };\n\n  Sticky.prototype.render = function () {\n    var _a = this.props,\n        disabled = _a.disabled,\n        disableResizing = _a.disableResizing,\n        style = _a.style,\n        className = _a.className,\n        overflowScroll = _a.overflowScroll;\n    return createElement(Fragment, null, createElement(StickyPlaceholder, {\n      className: className,\n      style: this.state.useNativeSticky ? __assign({\n        position: 'sticky',\n        top: this.props.defaultOffsetTop\n      }, style) : style,\n      disabled: disabled,\n      forwardRef: this.placeholderRef,\n      stickyRef: this.stickyRef,\n      disableResizing: disableResizing\n    }, this.renderSticky), createElement(ObserveViewport, {\n      disableScrollUpdates: disabled,\n      disableDimensionsUpdates: disabled || overflowScroll !== 'flow',\n      onUpdate: this.handleScrollUpdate,\n      recalculateLayoutBeforeUpdate: this.recalculateLayoutBeforeUpdate,\n      priority: this.state.isNearToViewport ? 'highest' : 'low'\n    }));\n  };\n\n  Sticky.defaultProps = {\n    stickyOffset: {\n      top: 0,\n      height: 0\n    },\n    defaultOffsetTop: 0,\n    disableResizing: false,\n    disableHardwareAcceleration: false,\n    overflowScroll: 'end',\n    experimentalNative: false,\n    style: {}\n  };\n  return Sticky;\n}(PureComponent);\n\nvar Sticky$1 = connect()(Sticky);\n\nvar calcPositionStyles = function (rect, scroll, _a) {\n  var _b = _a.offsetTop,\n      offsetTop = _b === void 0 ? 0 : _b;\n  var rectTop = Math.round(rect.top);\n  var scrollY = Math.round(scroll.y);\n\n  if (scroll.isScrollingDown) {\n    // disable sticky mode above the top offset while scrolling down\n    if (rectTop > 0 && scrollY < offsetTop) {\n      return {\n        position: 'absolute',\n        top: 0\n      };\n    } // element is visible and scrolls down\n\n\n    return {\n      position: 'absolute',\n      top: Math.max(scrollY - offsetTop + rectTop, 0)\n    };\n  }\n\n  var isTopVisible = rectTop >= 0;\n  var isBottomVisible = rectTop + rect.height <= 0; // element is visible and scrolls up\n\n  if (!isTopVisible && !isBottomVisible) {\n    return {\n      position: 'absolute',\n      top: scrollY - offsetTop + rectTop\n    };\n  } // disable sticky mode above the top offset while scrolling up\n\n\n  if (scrollY <= offsetTop) {\n    return {\n      position: 'absolute',\n      top: 0\n    };\n  }\n\n  if (Math.round(scroll.yDTurn) === 0) {\n    // scroll direction changed from down to up and the element was not visible\n    if (isBottomVisible) {\n      return {\n        position: 'absolute',\n        top: Math.round(scroll.yTurn) - offsetTop - rect.height\n      };\n    } // scroll direction changed from down to up and the element was fully visible\n\n\n    return {\n      position: 'absolute',\n      top: Math.max(scrollY - offsetTop, 0)\n    };\n  } // set sticky\n\n\n  return {\n    position: 'fixed',\n    top: 0\n  };\n};\n\nvar StickyScrollUp =\n/** @class */\nfunction (_super) {\n  __extends(StickyScrollUp, _super);\n\n  function StickyScrollUp() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.stickyRef = createRef();\n    _this.placeholderRef = createRef();\n    _this.stickyOffset = null;\n    _this.stickyOffsetHeight = 0;\n    _this.state = {\n      styles: {},\n      isNearToViewport: false,\n      isSticky: false\n    };\n\n    _this.isNearToViewport = function (rect) {\n      var padding = 700;\n      return rect.top - padding < 0;\n    };\n\n    _this.recalculateLayoutBeforeUpdate = function () {\n      return {\n        placeholderRect: _this.placeholderRef.current.getBoundingClientRect(),\n        stickyRect: _this.stickyRef.current.getBoundingClientRect()\n      };\n    };\n\n    _this.handleViewportUpdate = function (_a, _b) {\n      var scroll = _a.scroll;\n      var stickyRect = _b.stickyRect,\n          placeholderRect = _b.placeholderRect;\n\n      if (_this.props.disabled) {\n        return;\n      } // in case children is not a function renderArgs will never be used\n\n\n      var willRenderAsAFunction = typeof _this.props.children === 'function';\n      var nextOffset = Math.max(Math.round(stickyRect.bottom), 0);\n      var nextOffsetHeight = stickyRect.height;\n      var offsetDidChange = _this.stickyOffset !== nextOffset;\n      var offsetHeightDidChange = _this.stickyOffsetHeight !== nextOffsetHeight;\n\n      var styles = _this.getStickyStyles(stickyRect, placeholderRect, scroll);\n\n      var stateStyles = _this.state.styles;\n      var stylesDidChange = !shallowEqualPositionStyles(styles, stateStyles);\n\n      var isNearToViewport = _this.isNearToViewport(stickyRect);\n\n      var isSticky = willRenderAsAFunction ? styles.top === 0 && styles.position === 'fixed' : false;\n      var isNearToViewportDidChange = _this.state.isNearToViewport !== isNearToViewport;\n      var isStickyDidChange = _this.state.isSticky !== isSticky;\n\n      if (_this.props.updateStickyOffset && (offsetDidChange || offsetHeightDidChange)) {\n        _this.props.updateStickyOffset(nextOffset, nextOffsetHeight);\n      }\n\n      if (!stylesDidChange && !isNearToViewportDidChange && !isStickyDidChange) {\n        return;\n      }\n\n      _this.setState({\n        styles: stylesDidChange ? styles : stateStyles,\n        isNearToViewport: isNearToViewport,\n        isSticky: isSticky\n      });\n    };\n\n    _this.renderSticky = function (_a) {\n      var isRecalculating = _a.isRecalculating;\n      var _b = _this.props,\n          disabled = _b.disabled,\n          children = _b.children,\n          stickyProps = _b.stickyProps;\n      return createElement(StickyElement, __assign({\n        forwardRef: _this.stickyRef,\n        positionStyle: _this.state.styles,\n        disabled: disabled || isRecalculating,\n        children: children,\n        renderArgs: {\n          isNearToViewport: _this.state.isNearToViewport,\n          isSticky: _this.state.isSticky\n        }\n      }, stickyProps));\n    };\n\n    return _this;\n  }\n\n  StickyScrollUp.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (this.props.updateStickyOffset && prevProps.disabled !== this.props.disabled) {\n      this.props.updateStickyOffset(this.props.disabled ? 0 : this.stickyOffset, this.stickyOffsetHeight);\n    }\n  };\n\n  StickyScrollUp.prototype.getStickyStyles = function (stickyRect, placeholderRect, scroll) {\n    var offsetTop = isNaN(this.props.defaultOffsetTop) ? Math.round(placeholderRect.top) + Math.round(scroll.y) : this.props.defaultOffsetTop;\n    var styles = calcPositionStyles(stickyRect, scroll, {\n      offsetTop: offsetTop\n    });\n\n    if (!this.props.disableHardwareAcceleration) {\n      var shouldAccelerate = this.isNearToViewport(stickyRect);\n\n      if (supportsWillChange) {\n        styles.willChange = shouldAccelerate ? 'position, top' : null;\n      } else {\n        styles.transform = shouldAccelerate ? \"translateZ(0)\" : null;\n      }\n    }\n\n    return styles;\n  };\n\n  StickyScrollUp.prototype.render = function () {\n    var _a = this.props,\n        disabled = _a.disabled,\n        disableResizing = _a.disableResizing,\n        style = _a.style,\n        className = _a.className;\n    return createElement(Fragment, null, createElement(StickyPlaceholder, {\n      className: className,\n      style: style,\n      disabled: disabled,\n      stickyRef: this.stickyRef,\n      disableResizing: disableResizing,\n      forwardRef: this.placeholderRef\n    }, this.renderSticky), createElement(ObserveViewport, {\n      disableScrollUpdates: disabled,\n      disableDimensionsUpdates: true,\n      onUpdate: this.handleViewportUpdate,\n      recalculateLayoutBeforeUpdate: this.recalculateLayoutBeforeUpdate,\n      priority: this.state.isNearToViewport ? 'highest' : 'low'\n    }));\n  };\n\n  StickyScrollUp.defaultProps = {\n    disableHardwareAcceleration: false,\n    disableResizing: false,\n    style: {}\n  };\n  return StickyScrollUp;\n}(PureComponent);\n\nvar StickyScrollUp$1 = connect()(StickyScrollUp);\nexport { Sticky$1 as Sticky, StickyScrollUpProvider as StickyProvider, StickyScrollUp$1 as StickyScrollUp };","map":{"version":3,"sources":["../lib/StickyProvider.tsx","../lib/StickyElement.tsx","../lib/StickyPlaceholder.tsx","../lib/utils.ts","../lib/Sticky.tsx","../lib/StickyScrollUp.tsx"],"names":["React.createContext","React.createElement","React.PureComponent","React.Component","React.createRef","connectStickyProvider"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { ViewportProvider } from 'react-viewport-utils';\n\nimport { IStickyInjectedProps } from './types';\n\nconst StickyGroupContext = React.createContext({\n  stickyOffset: { top: 0, height: 0 },\n  updateStickyOffset: (offset: number, height: number) => {},\n});\n\nexport const connect = () => <P extends object>(\n  WrappedComponent: React.ComponentType<P & IStickyInjectedProps>,\n) => {\n  const ConnectedComponent: React.SFC<P> = props => (\n    <StickyGroupContext.Consumer>\n      {context => (\n        <WrappedComponent\n          {...props}\n          stickyOffset={context.stickyOffset}\n          updateStickyOffset={context.updateStickyOffset}\n        />\n      )}\n    </StickyGroupContext.Consumer>\n  );\n\n  const displayName =\n    WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  ConnectedComponent.displayName = `connectSticky(${displayName})`;\n\n  return ConnectedComponent;\n};\n\nexport default class StickyScrollUpProvider extends React.PureComponent {\n  stickyOffset = {\n    top: 0,\n    height: 0,\n  };\n\n  updateStickyOffset = (stickyOffset: number, height: number) => {\n    this.stickyOffset.top = Math.min(stickyOffset, height);\n    this.stickyOffset.height = height;\n  };\n\n  render() {\n    return (\n      <ViewportProvider experimentalSchedulerEnabled>\n        <StickyGroupContext.Provider\n          value={{\n            updateStickyOffset: this.updateStickyOffset,\n            stickyOffset: this.stickyOffset,\n          }}\n        >\n          {this.props.children}\n        </StickyGroupContext.Provider>\n      </ViewportProvider>\n    );\n  }\n}\n","import * as React from 'react';\nimport { TRenderChildren, IPositionStyles } from './types';\n\ninterface IProps<R> {\n  disabled: boolean;\n  renderArgs?: R;\n  children: TRenderChildren<R>;\n  forwardRef?: React.RefObject<any>;\n  style?: React.CSSProperties;\n  positionStyle?: IPositionStyles;\n}\n\nconst baseStyles: React.CSSProperties = {\n  width: 'inherit',\n};\n\nconst prefixTransform = (transform: string): React.CSSProperties => ({\n  transform,\n  WebkitTransform: transform,\n  msTransform: transform,\n  OTransform: transform,\n});\n\nconst StickyElement = <R extends {}>({\n  children,\n  forwardRef,\n  style: overrideStyles = {},\n  positionStyle = {},\n  disabled,\n  renderArgs,\n  ...props\n}: IProps<R>) => {\n  const style: React.CSSProperties = !disabled\n    ? { ...baseStyles, ...positionStyle, ...overrideStyles }\n    : {};\n\n  if (style.transform) {\n    Object.assign(style, prefixTransform(style.transform));\n  }\n\n  return (\n    <div ref={forwardRef} style={style} {...props}>\n      {typeof children === 'function'\n        ? (children as (options: R) => React.ReactNode)(renderArgs)\n        : children}\n    </div>\n  );\n};\n\nexport default StickyElement;\n","import * as React from 'react';\nimport {\n  ObserveViewport,\n  IDimensions,\n  IRect,\n  requestAnimationFrame,\n} from 'react-viewport-utils';\n\ninterface IProps {\n  disableResizing: boolean;\n  disabled: boolean;\n  style: React.CSSProperties | null;\n  stickyRef: React.RefObject<any>;\n  children: (props: { isRecalculating: boolean }) => React.ReactNode;\n  className?: string;\n  forwardRef?: React.RefObject<any>;\n}\n\ninterface IState {\n  isRecalculating: boolean;\n  isWaitingForRecalculation: boolean;\n  stickyHeight: number | null;\n  stickyWidth: number | null;\n  clientSize: string | null;\n}\n\nclass StickyPlaceholder extends React.Component<IProps, IState> {\n  static defaultProps = {\n    style: {},\n  };\n\n  state: IState = {\n    isRecalculating: false,\n    isWaitingForRecalculation: false,\n    stickyHeight: null,\n    stickyWidth: null,\n    clientSize: null,\n  };\n\n  calculateSize = () => {\n    if (\n      this.props.stickyRef.current &&\n      !this.state.isRecalculating &&\n      this.state.isWaitingForRecalculation\n    ) {\n      return this.props.stickyRef.current.getBoundingClientRect();\n    }\n    return null;\n  };\n\n  handleDimensionsUpdate = (\n    { dimensions }: { dimensions: IDimensions },\n    stickyRect: IRect | null,\n  ) => {\n    const { width, clientWidth } = dimensions;\n    const nextClientSize = [width, clientWidth].join(',');\n\n    if (\n      !this.state.isWaitingForRecalculation &&\n      this.state.clientSize !== nextClientSize\n    ) {\n      this.setState(\n        {\n          clientSize: nextClientSize,\n          isRecalculating: true,\n          isWaitingForRecalculation: true,\n        },\n        () => {\n          requestAnimationFrame(() => {\n            this.setState({\n              isRecalculating: false,\n            });\n          });\n        },\n      );\n      return;\n    }\n\n    if (stickyRect && this.state.isWaitingForRecalculation) {\n      this.setState({\n        clientSize: nextClientSize,\n        stickyHeight: stickyRect.height,\n        stickyWidth: stickyRect.width,\n        isWaitingForRecalculation: false,\n      });\n      return;\n    }\n  };\n\n  render() {\n    const { children, disabled, style, className, forwardRef } = this.props;\n    const {\n      isRecalculating,\n      isWaitingForRecalculation,\n      stickyHeight,\n      stickyWidth,\n    } = this.state;\n    const isActive = !disabled && !isWaitingForRecalculation;\n    const baseStyle = { position: 'relative', ...style } as const;\n    const containerStyle: React.CSSProperties = isActive\n      ? ({\n          height: stickyHeight,\n          width: stickyWidth,\n          ...baseStyle,\n        } as const)\n      : baseStyle;\n    return (\n      <>\n        <div ref={forwardRef} style={containerStyle} className={className}>\n          {children({\n            isRecalculating: isWaitingForRecalculation,\n          })}\n        </div>\n        {!this.props.disableResizing && (\n          <ObserveViewport\n            disableScrollUpdates\n            disableDimensionsUpdates={isRecalculating}\n            onUpdate={this.handleDimensionsUpdate}\n            recalculateLayoutBeforeUpdate={this.calculateSize}\n            priority=\"highest\"\n          />\n        )}\n      </>\n    );\n  }\n}\n\nexport default StickyPlaceholder;\n","import { IPositionStyles } from './types';\n\nexport const supportsWillChange = (() => {\n  const isBrowser =\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined' &&\n    document.documentElement;\n  if (!isBrowser) {\n    return false;\n  }\n  return 'willChange' in document.documentElement.style;\n})();\n\nexport const supportsPositionSticky = (() => {\n  const isBrowser = typeof window !== 'undefined' && typeof CSS !== 'undefined';\n  if (!isBrowser) {\n    return false;\n  }\n  return CSS.supports ? CSS.supports('position: sticky') : false;\n})();\n\nexport const shallowEqualPositionStyles = (\n  a: IPositionStyles,\n  b: IPositionStyles,\n) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.position !== b.position) {\n    return false;\n  }\n  if (a.top !== b.top) {\n    return false;\n  }\n  if (a.transform !== b.transform) {\n    return false;\n  }\n  if (a.willChange !== b.willChange) {\n    return false;\n  }\n  return true;\n};\n","import * as React from 'react';\nimport {\n  ObserveViewport,\n  IRect,\n  IScroll,\n  IDimensions,\n} from 'react-viewport-utils';\n\nimport { connect as connectStickyProvider } from './StickyProvider';\nimport StickyElement from './StickyElement';\nimport StickyPlaceholder from './StickyPlaceholder';\nimport {\n  TRenderChildren,\n  IStickyComponentProps,\n  IStickyInjectedProps,\n  IPositionStyles,\n} from './types';\nimport {\n  supportsWillChange,\n  shallowEqualPositionStyles,\n  supportsPositionSticky,\n} from './utils';\n\ntype OverflowScrollType = 'flow' | 'end';\n\ninterface IOwnProps extends IStickyComponentProps {\n  /**\n   * The reference to the container to stick into. If this is not set, the component will be sticky regardless how far the user scrolls down.\n   */\n  container?: React.RefObject<any>;\n  /**\n   * The child node that is rendered within the sticky container. When rendered as a function it will add further information the the function which can be used e.g. to update stylings.\n   */\n  children?: TRenderChildren<{\n    isSticky: boolean;\n    isDockedToBottom: boolean;\n    isNearToViewport: boolean;\n    appliedOverflowScroll: OverflowScrollType;\n  }>;\n  /**\n   * Defines how the sticky element should react in case its bigger than the viewport.\n   * Different options are available:\n   * * end: The default value will keep the component sticky as long as it reaches the bottom of its container and only then will scroll down.\n   * * flow: The element scrolls with the flow of the scroll direction, therefore the content is easier to access.\n   */\n  overflowScroll?: OverflowScrollType;\n  /**\n   * A top offset to create a padding between the browser window and the sticky component when sticky.\n   */\n  defaultOffsetTop?: number;\n  /**\n   * Tries to detect when the usage of native `position: sticky` is possible and uses it as long as possible. This is an experimental property and might change in its behavior or disappear in the future.\n   */\n  experimentalNative?: boolean;\n}\n\ninterface IProps extends IOwnProps, IStickyInjectedProps {}\n\ninterface IState {\n  isSticky: boolean;\n  isDockedToBottom: boolean;\n  isNearToViewport: boolean;\n  appliedOverflowScroll: OverflowScrollType;\n  styles: IPositionStyles;\n  useNativeSticky: boolean;\n}\n\ninterface ILayoutSnapshot {\n  stickyRect: IRect;\n  containerRect: IRect;\n}\n\nclass Sticky extends React.PureComponent<IProps, IState> {\n  private stickyRef: React.RefObject<HTMLElement> = React.createRef();\n  private placeholderRef: React.RefObject<HTMLElement> = React.createRef();\n  private nativeStickyThrewOnce: boolean = false;\n\n  static defaultProps = {\n    stickyOffset: { top: 0, height: 0 },\n    defaultOffsetTop: 0,\n    disableResizing: false,\n    disableHardwareAcceleration: false,\n    overflowScroll: 'end' as OverflowScrollType,\n    experimentalNative: false,\n    style: {},\n  };\n\n  state: IState = {\n    isSticky: false,\n    isDockedToBottom: false,\n    isNearToViewport: false,\n    appliedOverflowScroll: 'end',\n    styles: {},\n    useNativeSticky: false,\n  };\n\n  get container() {\n    return this.props.container || this.placeholderRef;\n  }\n\n  get offsetTop() {\n    return this.props.stickyOffset.top + this.props.defaultOffsetTop;\n  }\n\n  hasContainer = () => {\n    return Boolean(this.props.container);\n  };\n\n  isNearToViewport = (rect: IRect): boolean => {\n    const padding = 700;\n    return rect.top - padding < 0 && rect.bottom + padding > 0;\n  };\n\n  getOverflowScrollType = (\n    rectSticky: IRect,\n    dimensions: IDimensions,\n  ): OverflowScrollType => {\n    return this.props.overflowScroll === 'flow' &&\n      this.calcHeightDifference(rectSticky, dimensions) > 0\n      ? 'flow'\n      : 'end';\n  };\n\n  isSticky = (rect: IRect, containerRect: IRect, dimensions: IDimensions) => {\n    if (!this.hasContainer()) {\n      return Math.round(containerRect.top) <= this.offsetTop;\n    }\n\n    if (Math.round(containerRect.top) > this.offsetTop) {\n      return false;\n    }\n\n    const height =\n      this.props.overflowScroll === 'flow'\n        ? Math.min(rect.height, dimensions.height)\n        : rect.height;\n    if (Math.round(containerRect.bottom) - this.offsetTop < height) {\n      return false;\n    }\n\n    return true;\n  };\n\n  shouldUseNativeSticky = (appliedOverflowScroll: OverflowScrollType) => {\n    if (\n      !this.props.experimentalNative ||\n      !supportsPositionSticky ||\n      appliedOverflowScroll !== 'end' ||\n      this.props.stickyOffset.top !== 0\n    ) {\n      return false;\n    }\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      !this.nativeStickyThrewOnce &&\n      (this.placeholderRef && this.placeholderRef.current.parentElement) !==\n        (this.props.container && this.props.container.current)\n    ) {\n      console.warn(\n        'react-stickup: a sticky element was used with property `experimentalNative` but its `container` is not the parent the sticky component. As the native sticky implementation always uses its parent element as the container. This can lead to unexpected results. It is therefore recommended to change the DOM structure so that the container is a direct parent of the Sticky component or to remove the `experimentalNative` property.',\n      );\n      this.nativeStickyThrewOnce = true;\n    }\n    return true;\n  };\n\n  isDockedToBottom = (\n    rect: IRect,\n    containerRect: IRect,\n    dimensions: IDimensions,\n  ) => {\n    if (!rect || !containerRect) {\n      return false;\n    }\n\n    if (!this.hasContainer()) {\n      return false;\n    }\n\n    if (rect.height > containerRect.height) {\n      return false;\n    }\n\n    const height =\n      this.props.overflowScroll === 'flow'\n        ? Math.min(rect.height, dimensions.height)\n        : rect.height;\n    if (Math.round(containerRect.bottom) - this.offsetTop >= height) {\n      return false;\n    }\n\n    return true;\n  };\n\n  calcHeightDifference(rectSticky: IRect, dimensions: IDimensions) {\n    if (!dimensions) {\n      return 0;\n    }\n    return Math.max(0, Math.round(rectSticky.height) - dimensions.height);\n  }\n\n  calcOverflowScrollFlowStickyStyles(\n    rectSticky: IRect,\n    containerRect: IRect,\n    scroll: IScroll,\n    dimensions: IDimensions,\n  ): IPositionStyles {\n    const containerTop = Math.round(containerRect.top);\n    const stickyTop = Math.round(rectSticky.top);\n    const scrollY = Math.round(scroll.y);\n    const scrollYTurn = Math.round(scroll.yTurn);\n    const heightDiff = this.calcHeightDifference(rectSticky, dimensions);\n    const containerTopOffset =\n      containerTop + scrollY - this.props.stickyOffset.height;\n    const isStickyBottomReached =\n      Math.round(rectSticky.bottom) <= dimensions.height;\n    const isContainerTopReached = containerTop < this.offsetTop;\n    const isTurnWithinHeightOffset =\n      scrollYTurn - heightDiff <= containerTopOffset;\n    const isTurnPointBeforeContainer = scrollYTurn < containerTopOffset;\n    const isTurnPointAfterContainer =\n      scrollYTurn > containerTopOffset + containerRect.height;\n    const isTurnPointWithinContainer = !(\n      isTurnPointBeforeContainer || isTurnPointAfterContainer\n    );\n    // scroll down AND sticky rect bottom not reached AND turn point not within the container OR\n    // scroll up AND container top not reached OR\n    //scroll up AND turns within the height diff AND turn point not within the container\n    if (\n      (scroll.isScrollingDown &&\n        !isStickyBottomReached &&\n        !isTurnPointWithinContainer) ||\n      (scroll.isScrollingUp && !isContainerTopReached) ||\n      (scroll.isScrollingUp &&\n        isTurnWithinHeightOffset &&\n        !isTurnPointWithinContainer)\n    ) {\n      return {\n        position: 'absolute',\n        top: 0,\n      };\n    }\n\n    // scroll down AND sticky bottom reached\n    if (scroll.isScrollingDown && isStickyBottomReached) {\n      return {\n        position: 'fixed',\n        top: -heightDiff,\n      };\n    }\n\n    const isStickyTopReached = stickyTop >= this.offsetTop;\n    // scroll down AND turn point within container OR\n    // scroll up AND turn point not before container AND not sticky top reached\n    if (\n      (scroll.isScrollingDown && isTurnPointWithinContainer) ||\n      (scroll.isScrollingUp &&\n        !isTurnPointBeforeContainer &&\n        !isStickyTopReached)\n    ) {\n      return {\n        position: 'absolute',\n        top: Math.abs(scrollY - stickyTop + (containerTop - scrollY)),\n      };\n    }\n\n    return {\n      position: 'fixed',\n      top: this.offsetTop,\n    };\n  }\n\n  calcPositionStyles(\n    rectSticky: IRect,\n    containerRect: IRect,\n    scroll: IScroll,\n    dimensions: IDimensions,\n  ): IPositionStyles {\n    if (this.isSticky(rectSticky, containerRect, dimensions)) {\n      if (this.getOverflowScrollType(rectSticky, dimensions) === 'flow') {\n        return this.calcOverflowScrollFlowStickyStyles(\n          rectSticky,\n          containerRect,\n          scroll,\n          dimensions,\n        );\n      }\n      const stickyOffset = this.props.stickyOffset.top;\n      const stickyHeight = this.props.stickyOffset.height;\n      const headIsFlexible = stickyOffset > 0 && stickyOffset < stickyHeight;\n      if (headIsFlexible) {\n        const relYTurn =\n          Math.round(scroll.yTurn - scroll.y + scroll.yDTurn) -\n          Math.round(containerRect.top);\n        return {\n          position: 'absolute',\n          top: relYTurn + this.offsetTop,\n        };\n      }\n\n      return {\n        position: 'fixed',\n        top: this.offsetTop,\n      };\n    }\n\n    if (this.isDockedToBottom(rectSticky, containerRect, dimensions)) {\n      return {\n        position: 'absolute',\n        top: containerRect.height - rectSticky.height,\n      };\n    }\n\n    return {\n      position: 'absolute',\n      top: 0,\n    };\n  }\n\n  getStickyStyles(\n    rect: IRect,\n    containerRect: IRect,\n    scroll: IScroll,\n    dimensions: IDimensions,\n  ): IPositionStyles {\n    const styles = this.calcPositionStyles(\n      rect,\n      containerRect,\n      scroll,\n      dimensions,\n    );\n\n    if (!this.props.disableHardwareAcceleration) {\n      const shouldAccelerate = this.isNearToViewport(rect);\n      if (supportsWillChange) {\n        styles.willChange = shouldAccelerate ? 'position, top' : null;\n      } else {\n        styles.transform = shouldAccelerate ? `translateZ(0)` : null;\n      }\n    }\n\n    return styles;\n  }\n\n  recalculateLayoutBeforeUpdate = (): ILayoutSnapshot => {\n    const containerRect = this.container.current.getBoundingClientRect();\n    const stickyRect = this.stickyRef.current.getBoundingClientRect();\n    return {\n      stickyRect,\n      containerRect,\n    };\n  };\n\n  handleScrollUpdate = (\n    { scroll, dimensions }: { scroll: IScroll; dimensions: IDimensions },\n    { stickyRect, containerRect }: ILayoutSnapshot,\n  ) => {\n    if (this.props.disabled) {\n      return;\n    }\n    // in case children is not a function renderArgs will never be used\n    const willRenderAsAFunction = typeof this.props.children === 'function';\n    const appliedOverflowScroll = this.getOverflowScrollType(\n      stickyRect,\n      dimensions,\n    );\n\n    const useNativeSticky = this.shouldUseNativeSticky(appliedOverflowScroll);\n\n    const styles = useNativeSticky\n      ? {}\n      : this.getStickyStyles(stickyRect, containerRect, scroll, dimensions);\n    const stateStyles = this.state.styles;\n    const stylesDidChange = !shallowEqualPositionStyles(styles, stateStyles);\n    const isSticky = willRenderAsAFunction\n      ? this.isSticky(stickyRect, containerRect, dimensions)\n      : false;\n    const isDockedToBottom = willRenderAsAFunction\n      ? this.isDockedToBottom(stickyRect, containerRect, dimensions)\n      : false;\n    const isNearToViewport = this.isNearToViewport(stickyRect);\n    const useNativeStickyDidChange =\n      this.state.useNativeSticky !== useNativeSticky;\n    const isStickyDidChange = this.state.isSticky !== isSticky;\n    const isDockedToBottomDidChange =\n      this.state.isDockedToBottom !== isDockedToBottom;\n    const isNearToViewportDidChange =\n      this.state.isNearToViewport !== isNearToViewport;\n    const appliedOverflowScrollDidChange =\n      appliedOverflowScroll !== this.state.appliedOverflowScroll;\n\n    if (\n      !useNativeStickyDidChange &&\n      !stylesDidChange &&\n      !isStickyDidChange &&\n      !isDockedToBottomDidChange &&\n      !isNearToViewportDidChange &&\n      !appliedOverflowScrollDidChange\n    ) {\n      return;\n    }\n\n    this.setState({\n      useNativeSticky,\n      isSticky,\n      isDockedToBottom,\n      isNearToViewport,\n      appliedOverflowScroll,\n      styles: stylesDidChange ? styles : stateStyles,\n    });\n  };\n\n  renderSticky = ({ isRecalculating }: { isRecalculating: boolean }) => {\n    const { children, disabled, stickyProps } = this.props;\n    return (\n      <StickyElement<\n        TRenderChildren<{\n          isSticky: boolean;\n          isDockedToBottom: boolean;\n          isNearToViewport: boolean;\n          appliedOverflowScroll: OverflowScrollType;\n        }>\n      >\n        forwardRef={this.stickyRef}\n        positionStyle={this.state.styles}\n        disabled={disabled || isRecalculating}\n        children={children}\n        renderArgs={{\n          isSticky: this.state.isSticky,\n          isDockedToBottom: this.state.isDockedToBottom,\n          isNearToViewport: this.state.isNearToViewport,\n          appliedOverflowScroll: this.state.appliedOverflowScroll,\n        }}\n        {...stickyProps}\n      />\n    );\n  };\n\n  render() {\n    const {\n      disabled,\n      disableResizing,\n      style,\n      className,\n      overflowScroll,\n    } = this.props;\n    return (\n      <>\n        <StickyPlaceholder\n          className={className}\n          style={\n            this.state.useNativeSticky\n              ? {\n                  position: 'sticky',\n                  top: this.props.defaultOffsetTop,\n                  ...style,\n                }\n              : style\n          }\n          disabled={disabled}\n          forwardRef={this.placeholderRef}\n          stickyRef={this.stickyRef}\n          disableResizing={disableResizing}\n        >\n          {this.renderSticky}\n        </StickyPlaceholder>\n        <ObserveViewport\n          disableScrollUpdates={disabled}\n          disableDimensionsUpdates={disabled || overflowScroll !== 'flow'}\n          onUpdate={this.handleScrollUpdate}\n          recalculateLayoutBeforeUpdate={this.recalculateLayoutBeforeUpdate}\n          priority={this.state.isNearToViewport ? 'highest' : 'low'}\n        />\n      </>\n    );\n  }\n}\n\nexport default connectStickyProvider()<IOwnProps>(Sticky);\n","import * as React from 'react';\nimport { ObserveViewport, IRect, IScroll } from 'react-viewport-utils';\n\nimport { connect as connectStickyProvider } from './StickyProvider';\nimport StickyElement from './StickyElement';\nimport StickyPlaceholder from './StickyPlaceholder';\nimport {\n  TRenderChildren,\n  IStickyComponentProps,\n  IStickyInjectedProps,\n  IPositionStyles,\n} from './types';\nimport { supportsWillChange, shallowEqualPositionStyles } from './utils';\n\ninterface IOwnProps extends IStickyComponentProps {\n  /**\n   * The child node that is rendered within the sticky container. When rendered as a function it will add further information the the function which can be used e.g. to update stylings.\n   */\n  children?: TRenderChildren<{\n    isNearToViewport: boolean;\n    isSticky: boolean;\n  }>;\n  /**\n   * When not initialized as the first element within the page (directly at the top) this allows to set an offset by hand from where the component will be sticky.\n   * @deprecated If not set, the start position is now calculated by default as it was already the case for the `Sticky` component. As there is no use case for this property anymore it will be removed in the future.\n   */\n  defaultOffsetTop?: number;\n}\n\ninterface IProps extends IOwnProps, IStickyInjectedProps {}\n\ninterface IState {\n  styles: IPositionStyles;\n  isNearToViewport: boolean;\n  isSticky: boolean;\n}\n\nconst calcPositionStyles = (\n  rect: IRect,\n  scroll: IScroll,\n  { offsetTop = 0 },\n): IPositionStyles => {\n  const rectTop = Math.round(rect.top);\n  const scrollY = Math.round(scroll.y);\n  if (scroll.isScrollingDown) {\n    // disable sticky mode above the top offset while scrolling down\n    if (rectTop > 0 && scrollY < offsetTop) {\n      return {\n        position: 'absolute',\n        top: 0,\n      };\n    }\n\n    // element is visible and scrolls down\n    return {\n      position: 'absolute',\n      top: Math.max(scrollY - offsetTop + rectTop, 0),\n    };\n  }\n\n  const isTopVisible = rectTop >= 0;\n  const isBottomVisible = rectTop + rect.height <= 0;\n  // element is visible and scrolls up\n  if (!isTopVisible && !isBottomVisible) {\n    return {\n      position: 'absolute',\n      top: scrollY - offsetTop + rectTop,\n    };\n  }\n\n  // disable sticky mode above the top offset while scrolling up\n  if (scrollY <= offsetTop) {\n    return {\n      position: 'absolute',\n      top: 0,\n    };\n  }\n\n  if (Math.round(scroll.yDTurn) === 0) {\n    // scroll direction changed from down to up and the element was not visible\n    if (isBottomVisible) {\n      return {\n        position: 'absolute',\n        top: Math.round(scroll.yTurn) - offsetTop - rect.height,\n      };\n    }\n    // scroll direction changed from down to up and the element was fully visible\n    return {\n      position: 'absolute',\n      top: Math.max(scrollY - offsetTop, 0),\n    };\n  }\n\n  // set sticky\n  return {\n    position: 'fixed',\n    top: 0,\n  };\n};\n\nclass StickyScrollUp extends React.PureComponent<IProps, IState> {\n  private stickyRef: React.RefObject<any> = React.createRef();\n  private placeholderRef: React.RefObject<any> = React.createRef();\n  private stickyOffset: number | null = null;\n  private stickyOffsetHeight: number = 0;\n\n  static defaultProps = {\n    disableHardwareAcceleration: false,\n    disableResizing: false,\n    style: {},\n  };\n\n  state: IState = {\n    styles: {},\n    isNearToViewport: false,\n    isSticky: false,\n  };\n\n  componentDidUpdate(prevProps: IProps, prevState: IState) {\n    if (\n      this.props.updateStickyOffset &&\n      prevProps.disabled !== this.props.disabled\n    ) {\n      this.props.updateStickyOffset(\n        this.props.disabled ? 0 : this.stickyOffset,\n        this.stickyOffsetHeight,\n      );\n    }\n  }\n\n  isNearToViewport = (rect: IRect): boolean => {\n    const padding = 700;\n    return rect.top - padding < 0;\n  };\n\n  getStickyStyles(stickyRect: IRect, placeholderRect: IRect, scroll: IScroll) {\n    const offsetTop = isNaN(this.props.defaultOffsetTop)\n      ? Math.round(placeholderRect.top) + Math.round(scroll.y)\n      : this.props.defaultOffsetTop;\n    const styles = calcPositionStyles(stickyRect, scroll, {\n      offsetTop,\n    });\n\n    if (!this.props.disableHardwareAcceleration) {\n      const shouldAccelerate = this.isNearToViewport(stickyRect);\n      if (supportsWillChange) {\n        styles.willChange = shouldAccelerate ? 'position, top' : null;\n      } else {\n        styles.transform = shouldAccelerate ? `translateZ(0)` : null;\n      }\n    }\n\n    return styles;\n  }\n\n  recalculateLayoutBeforeUpdate = (): {\n    stickyRect: IRect;\n    placeholderRect: IRect;\n  } => {\n    return {\n      placeholderRect: this.placeholderRef.current.getBoundingClientRect(),\n      stickyRect: this.stickyRef.current.getBoundingClientRect(),\n    };\n  };\n\n  handleViewportUpdate = (\n    { scroll }: { scroll: IScroll },\n    {\n      stickyRect,\n      placeholderRect,\n    }: { stickyRect: IRect; placeholderRect: IRect },\n  ) => {\n    if (this.props.disabled) {\n      return;\n    }\n    // in case children is not a function renderArgs will never be used\n    const willRenderAsAFunction = typeof this.props.children === 'function';\n\n    const nextOffset = Math.max(Math.round(stickyRect.bottom), 0);\n    const nextOffsetHeight = stickyRect.height;\n    const offsetDidChange = this.stickyOffset !== nextOffset;\n    const offsetHeightDidChange = this.stickyOffsetHeight !== nextOffsetHeight;\n\n    const styles = this.getStickyStyles(stickyRect, placeholderRect, scroll);\n    const stateStyles = this.state.styles;\n    const stylesDidChange = !shallowEqualPositionStyles(styles, stateStyles);\n    const isNearToViewport = this.isNearToViewport(stickyRect);\n    const isSticky = willRenderAsAFunction\n      ? styles.top === 0 && styles.position === 'fixed'\n      : false;\n    const isNearToViewportDidChange =\n      this.state.isNearToViewport !== isNearToViewport;\n    const isStickyDidChange = this.state.isSticky !== isSticky;\n\n    if (\n      this.props.updateStickyOffset &&\n      (offsetDidChange || offsetHeightDidChange)\n    ) {\n      this.props.updateStickyOffset(nextOffset, nextOffsetHeight);\n    }\n\n    if (!stylesDidChange && !isNearToViewportDidChange && !isStickyDidChange) {\n      return;\n    }\n\n    this.setState({\n      styles: stylesDidChange ? styles : stateStyles,\n      isNearToViewport,\n      isSticky,\n    });\n  };\n\n  renderSticky = ({ isRecalculating }: { isRecalculating: boolean }) => {\n    const { disabled, children, stickyProps } = this.props;\n    return (\n      <StickyElement<\n        TRenderChildren<{\n          isNearToViewport: boolean;\n          isSticky: boolean;\n        }>\n      >\n        forwardRef={this.stickyRef}\n        positionStyle={this.state.styles}\n        disabled={disabled || isRecalculating}\n        children={children}\n        renderArgs={{\n          isNearToViewport: this.state.isNearToViewport,\n          isSticky: this.state.isSticky,\n        }}\n        {...stickyProps}\n      />\n    );\n  };\n\n  render() {\n    const { disabled, disableResizing, style, className } = this.props;\n    return (\n      <>\n        <StickyPlaceholder\n          className={className}\n          style={style}\n          disabled={disabled}\n          stickyRef={this.stickyRef}\n          disableResizing={disableResizing}\n          forwardRef={this.placeholderRef}\n        >\n          {this.renderSticky}\n        </StickyPlaceholder>\n        <ObserveViewport\n          disableScrollUpdates={disabled}\n          disableDimensionsUpdates\n          onUpdate={this.handleViewportUpdate}\n          recalculateLayoutBeforeUpdate={this.recalculateLayoutBeforeUpdate}\n          priority={this.state.isNearToViewport ? 'highest' : 'low'}\n        />\n      </>\n    );\n  }\n}\n\nexport default connectStickyProvider()<IOwnProps>(StickyScrollUp);\n"]},"metadata":{},"sourceType":"module"}